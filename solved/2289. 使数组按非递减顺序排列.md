# 2289. 使数组按非递减顺序排列

## 题目描述

给你一个下标从 0 开始的整数数组 nums 。在一步操作中，移除所有满足  nums[i - 1] > nums[i] 的 nums[i] ，其中 0 < i < nums.length 。

重复执行步骤，直到 nums 变为 非递减 数组，返回所需执行的操作数。

```
示例 1：
输入：nums = [5,3,4,4,7,3,6,11,8,5,11]
输出：3
解释：执行下述几个步骤：
- 步骤 1 ：[5,3,4,4,7,3,6,11,8,5,11] 变为 [5,4,4,7,6,11,11]
- 步骤 2 ：[5,4,4,7,6,11,11] 变为 [5,4,7,11,11]
- 步骤 3 ：[5,4,7,11,11] 变为 [5,7,11,11]
[5,7,11,11] 是一个非递减数组，因此，返回 3 。

示例 2：
输入：nums = [4,5,7,7,13]
输出：0
解释：nums 已经是一个非递减数组，因此，返回 0 。
```

提示：

$1 <= nums.length <= 10^5$
$1 <= nums[i] <= 10^9$

## 解题思路

### 单调栈+动态规划

- 使用单调栈存储递减序列，若遍历到的当前元素值大于栈顶元素，则栈顶元素出栈，直到栈空或栈顶元素比他大，实际是为了**找到左侧第一个比他大的元素**，因为它会在第一个比它大的元素处消除，它需要知道需要几轮操作它才能到第一个比它大的元素处
  同时通过数组记录当前元素需要几轮操作消除
- 若比栈顶元素小，则只需要一轮，因为根据规则：
  ```
  10 9 8 7 5
  // 经过一轮后：
  10
  ```
- 若比栈顶元素大，则不断出栈直到找到第一个比他大的元素

  1. 当找到时栈不为空，找出出栈元素所需轮次的最大值，以最大值加一作为自己的轮次值，因为找到的最大值即为，消除前面所有元素所需的最大轮次，而除了消除前面所需元素的值外，还要多花一轮消除自己的值：

  ```
  10 5 4 7 6 8
  0  1 1 2 1 3 // 消除所需轮次
  // 第一轮
  10 7 8
  // 第二轮
  10 8
  // 第三轮
  10
  ```

  对于当前元素而言，他的左侧第一个比它大的值，有可能会在他之前被消除，例如：

  ```
  10 8 4 7
  // 第一轮
  10 7
  // 第二轮
  10
  ```

  但是，如果该元素 k(8)被消除，说明该元素左侧的将他消除的元素 x(10)大于他，所以他同样可以消除当前元素，且所需轮次并不会发生变化，因为原来 k(8)右侧的元素不会发生变化，他们仍然小于 x(10)，同样需要和以前相同的轮次数被消除。 2. 当栈为空，说明该值比栈中第一个元素还大，该元素遇到第一个元素也不会消除，即存在于最终结果中，该元素位置的值为 0：

  ```
  10 9 8 12
  0  1 1 0  // 消除所需轮次
  ```

```cpp
class Solution {
public:
    int totalSteps(vector<int>& nums) {
        vector<int> times(nums.size(), 0); // 记录每个位置的元素需要几轮消除
        stack<int> s;
        auto res = 0;
        for(int i = 0; i < nums.size(); ++i) {
            int cur = 0;
            while(!s.empty() && nums[s.top()] <= nums[i]) {
                cur = max(cur, times[s.top()]);
                s.pop();
            }
            if(!s.empty()) {
                times[i] = cur+1;
                res = max(res, cur+1);
            } else {
                times[i] = 0;
            }
            s.push(i);
        }
        return res;
    }
};
```
